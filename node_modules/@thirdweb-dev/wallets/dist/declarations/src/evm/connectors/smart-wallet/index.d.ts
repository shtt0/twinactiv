import { Chain } from "@thirdweb-dev/chains";
import { ConnectParams, Connector } from "../../interfaces/connector";
import { AccountContractInfo, FactoryContractInfo, SmartWalletConfig, SmartWalletConnectionArgs } from "./types";
import { EVMWallet } from "../../interfaces";
import { ERC4337EthersSigner } from "./lib/erc4337-signer";
import { BigNumber, ethers, providers, utils } from "ethers";
import { SignerPermissionsInput, SignerWithPermissions, SmartContract, Transaction, TransactionResult } from "@thirdweb-dev/sdk";
export declare class SmartWalletConnector extends Connector<SmartWalletConnectionArgs> {
    protected config: SmartWalletConfig;
    private aaProvider;
    private accountApi;
    personalWallet?: EVMWallet;
    chainId?: number;
    constructor(config: SmartWalletConfig);
    initialize(params: ConnectParams<SmartWalletConnectionArgs>): Promise<void>;
    connect(connectionArgs: ConnectParams<SmartWalletConnectionArgs>): Promise<string>;
    getProvider(): Promise<providers.Provider>;
    getSigner(): Promise<ERC4337EthersSigner>;
    getAddress(): Promise<string>;
    isConnected(): Promise<boolean>;
    disconnect(): Promise<void>;
    switchChain(chainId: number): Promise<void>;
    setupListeners(): Promise<void>;
    updateChains(chains: Chain[]): void;
    /**
     * Check whether the connected signer can execute a given transaction using the smart wallet.
     * @param transaction - the transaction to execute using the smart wallet.
     * @returns whether the connected signer can execute the transaction using the smart wallet.
     */
    hasPermissionToExecute(transaction: Transaction): Promise<boolean>;
    /**
     * Send a single transaction without waiting for confirmations
     * @param transaction - the transaction to send
     * @returns the awaitable transaction
     */
    send(transaction: Transaction): Promise<providers.TransactionResponse>;
    /**
     * Execute a single transaction (waiting for confirmations)
     * @param transaction - the transaction to execute
     * @returns the transaction receipt
     */
    execute(transaction: Transaction): Promise<TransactionResult>;
    sendBatch(transactions: Transaction<any>[]): Promise<providers.TransactionResponse>;
    /**
     * Execute multiple transactions in a single batch
     * @param transactions - the transactions to execute
     * @returns the transaction receipt
     */
    executeBatch(transactions: Transaction<any>[]): Promise<TransactionResult>;
    sendRaw(transaction: utils.Deferrable<providers.TransactionRequest>): Promise<providers.TransactionResponse>;
    executeRaw(transaction: utils.Deferrable<providers.TransactionRequest>): Promise<{
        receipt: ethers.providers.TransactionReceipt;
    }>;
    sendBatchRaw(transactions: utils.Deferrable<providers.TransactionRequest>[]): Promise<ethers.providers.TransactionResponse>;
    executeBatchRaw(transactions: utils.Deferrable<providers.TransactionRequest>[]): Promise<{
        receipt: ethers.providers.TransactionReceipt;
    }>;
    estimate(transaction: Transaction): Promise<{
        ether: string;
        wei: BigNumber;
        details: {
            deployGasLimit: BigNumber;
            transactionGasLimit: BigNumber;
            gasPrice: BigNumber;
            transactionCost: BigNumber;
            deployCost: BigNumber;
            totalCost: BigNumber;
        };
    }>;
    estimateRaw(transaction: utils.Deferrable<providers.TransactionRequest>): Promise<{
        ether: string;
        wei: BigNumber;
        details: {
            deployGasLimit: BigNumber;
            transactionGasLimit: BigNumber;
            gasPrice: BigNumber;
            transactionCost: BigNumber;
            deployCost: BigNumber;
            totalCost: BigNumber;
        };
    }>;
    estimateBatch(transactions: Transaction<any>[]): Promise<{
        ether: string;
        wei: BigNumber;
        details: {
            deployGasLimit: BigNumber;
            transactionGasLimit: BigNumber;
            gasPrice: BigNumber;
            transactionCost: BigNumber;
            deployCost: BigNumber;
            totalCost: BigNumber;
        };
    }>;
    estimateBatchRaw(transactions: utils.Deferrable<providers.TransactionRequest>[]): Promise<{
        ether: string;
        wei: BigNumber;
        details: {
            deployGasLimit: BigNumber;
            transactionGasLimit: BigNumber;
            gasPrice: BigNumber;
            transactionCost: BigNumber;
            deployCost: BigNumber;
            totalCost: BigNumber;
        };
    }>;
    /**
     * Manually deploy the smart wallet contract. If already deployed this will throw an error.
     * Note that this is not necessary as the smart wallet will be deployed automatically on the first transaction the user makes.
     * @returns the transaction receipt
     */
    deploy(): Promise<TransactionResult>;
    /**
     * Check if the smart wallet contract is deployed
     * @returns true if the smart wallet contract is deployed
     */
    isDeployed(): Promise<boolean>;
    deployIfNeeded(): Promise<void>;
    grantPermissions(target: string, permissions: SignerPermissionsInput): Promise<TransactionResult>;
    revokePermissions(target: string): Promise<TransactionResult>;
    addAdmin(target: string): Promise<TransactionResult>;
    removeAdmin(target: string): Promise<TransactionResult>;
    getAllActiveSigners(): Promise<SignerWithPermissions[]>;
    /**
     * Get the underlying account contract of the smart wallet.
     * @returns the account contract of the smart wallet.
     */
    getAccountContract(): Promise<SmartContract>;
    /**
     * Get the underlying account factory contract of the smart wallet.
     * @returns the account factory contract.
     */
    getFactoryContract(): Promise<SmartContract>;
    protected defaultFactoryInfo(): FactoryContractInfo;
    protected defaultAccountInfo(): AccountContractInfo;
    private estimateTx;
    private estimateDeploymentGasLimit;
    private prepareBatchRaw;
    private prepareBatchTx;
}
//# sourceMappingURL=index.d.ts.map