import { AbstractClientWallet, WalletOptions } from "./base";
import type { ConnectParams } from "../interfaces/connector";
import type { SmartWalletConfig, SmartWalletConnectionArgs } from "../connectors/smart-wallet/types";
import type { SmartWalletConnector as SmartWalletConnectorType } from "../connectors/smart-wallet";
import { Transaction, TransactionResult, SmartContract, SignerPermissionsInput, SignerWithPermissions } from "@thirdweb-dev/sdk";
import { providers, utils, Bytes } from "ethers";
export type * from "../connectors/smart-wallet/types";
export { type AccessibleSmartWallets, getAllSigners, getAllSmartWallets, getSmartWalletAddress, isSmartWalletDeployed, } from "../connectors/smart-wallet/utils";
export type { PaymasterAPI } from "@account-abstraction/sdk";
export declare class SmartWallet extends AbstractClientWallet<SmartWalletConfig, SmartWalletConnectionArgs> {
    connector?: SmartWalletConnectorType;
    static meta: {
        name: string;
        iconURL: string;
    };
    static id: string;
    get walletName(): string;
    constructor(options: WalletOptions<SmartWalletConfig>);
    getConnector(): Promise<SmartWalletConnectorType>;
    getPersonalWallet(): import("..").EVMWallet | undefined;
    /**
     * @returns the signature of the message
     */
    signMessage(message: Bytes | string): Promise<string>;
    /**
     * @returns the signature of the message (for legacy EIP-1271 signature verification)
     */
    private signMessageLegacy;
    /**
     * Check whether the connected signer can execute a given transaction using the smart wallet.
     * @param transaction - the transaction to execute using the smart wallet.
     * @returns whether the connected signer can execute the transaction using the smart wallet.
     */
    hasPermissionToExecute(transaction: Transaction): Promise<boolean>;
    /**
     * Send a single transaction without waiting for confirmations
     * @param transaction - the transaction to send
     * @returns the transaction result
     */
    send(transaction: Transaction): Promise<providers.TransactionResponse>;
    /**
     * Execute a single transaction and wait for confirmations
     * @param transaction - the transaction to execute
     * @returns the transaction receipt
     */
    execute(transaction: Transaction): Promise<TransactionResult>;
    /**
     * Send a multiple transaction in a batch without waiting for confirmations
     * @param transactions - the transactions to send
     * @returns the transaction result
     */
    sendBatch(transactions: Transaction[]): Promise<providers.TransactionResponse>;
    /**
     * Execute multiple transactions in a single batch and wait for confirmations
     * @param transactions - the transactions to execute
     * @returns the transaction receipt
     */
    executeBatch(transactions: Transaction<any>[]): Promise<TransactionResult>;
    /**
     * Send a single raw transaction without waiting for confirmations
     * @param transaction - the transaction to send
     * @returns the transaction result
     */
    sendRaw(transaction: utils.Deferrable<providers.TransactionRequest>): Promise<providers.TransactionResponse>;
    /**
     * Execute a single raw transaction and wait for confirmations
     * @param transaction - the transaction to execute
     * @returns the transaction receipt
     */
    executeRaw(transaction: utils.Deferrable<providers.TransactionRequest>): Promise<TransactionResult>;
    /**
     * Estimate the gas cost of a single transaction
     * @param transaction - the transaction to estimate
     * @returns
     */
    estimate(transaction: Transaction<any>): Promise<{
        ether: string;
        wei: import("ethers").BigNumber;
        details: {
            deployGasLimit: import("ethers").BigNumber;
            transactionGasLimit: import("ethers").BigNumber;
            gasPrice: import("ethers").BigNumber;
            transactionCost: import("ethers").BigNumber;
            deployCost: import("ethers").BigNumber;
            totalCost: import("ethers").BigNumber;
        };
    }>;
    /**
     * Estimate the gas cost of a batch of transactions
     * @param transactions - the transactions to estimate
     * @returns
     */
    estimateBatch(transactions: Transaction<any>[]): Promise<{
        ether: string;
        wei: import("ethers").BigNumber;
        details: {
            deployGasLimit: import("ethers").BigNumber;
            transactionGasLimit: import("ethers").BigNumber;
            gasPrice: import("ethers").BigNumber;
            transactionCost: import("ethers").BigNumber;
            deployCost: import("ethers").BigNumber;
            totalCost: import("ethers").BigNumber;
        };
    }>;
    /**
     * Estimate the gas cost of a single raw transaction
     * @param transactions - the transactions to estimate
     * @returns
     */
    estimateRaw(transactions: utils.Deferrable<providers.TransactionRequest>): Promise<{
        ether: string;
        wei: import("ethers").BigNumber;
        details: {
            deployGasLimit: import("ethers").BigNumber;
            transactionGasLimit: import("ethers").BigNumber;
            gasPrice: import("ethers").BigNumber;
            transactionCost: import("ethers").BigNumber;
            deployCost: import("ethers").BigNumber;
            totalCost: import("ethers").BigNumber;
        };
    }>;
    /**
     * Estimate the gas cost of a batch of raw transactions
     * @param transactions - the transactions to estimate
     * @returns
     */
    estimateBatchRaw(transactions: utils.Deferrable<providers.TransactionRequest>[]): Promise<{
        ether: string;
        wei: import("ethers").BigNumber;
        details: {
            deployGasLimit: import("ethers").BigNumber;
            transactionGasLimit: import("ethers").BigNumber;
            gasPrice: import("ethers").BigNumber;
            transactionCost: import("ethers").BigNumber;
            deployCost: import("ethers").BigNumber;
            totalCost: import("ethers").BigNumber;
        };
    }>;
    /**
     * Send multiple raw transaction in a batch without waiting for confirmations
     * @param transactions - the transactions to send
     * @returns the transaction result
     */
    sendBatchRaw(transactions: utils.Deferrable<providers.TransactionRequest>[]): Promise<providers.TransactionResponse>;
    /**
     * Execute multiple raw transactions in a single batch and wait for confirmations
     * @param transactions - the transactions to execute
     * @returns the transaction receipt
     */
    executeBatchRaw(transactions: utils.Deferrable<providers.TransactionRequest>[]): Promise<TransactionResult>;
    /**
     * Manually deploy the smart wallet contract. If already deployed this will throw an error.
     * Note that this is not necessary as the smart wallet will be deployed automatically on the first transaction the user makes.
     * @returns the transaction receipt
     */
    deploy(): Promise<TransactionResult>;
    /**
     * Manually deploy the smart wallet contract. If already deployed this will do nothing.
     * Note that this is not necessary as the smart wallet will be deployed automatically on the first transaction the user makes.
     * @returns the transaction receipt
     */
    deployIfNeeded(): Promise<void>;
    /**
     * Check if the smart wallet contract is deployed
     * @returns true if the smart wallet contract is deployed
     */
    isDeployed(): Promise<boolean>;
    /**
     * Create and add a session key to the smart wallet.
     * @param keyAddress - the address of the session key to add.
     * @param permissions - the permissions to grant to the session key.
     */
    createSessionKey(keyAddress: string, permissions: SignerPermissionsInput): Promise<TransactionResult>;
    /**
     * Remove a session key from the smart wallet.
     * @param keyAddress - the address of the session key to remove.
     */
    revokeSessionKey(keyAddress: string): Promise<TransactionResult>;
    /**
     * Add another admin to the smart wallet.
     * @param adminAddress - the address of the admin to add.
     */
    addAdmin(adminAddress: string): Promise<TransactionResult>;
    /**
     * Remove an admin from the smart wallet.
     * @param adminAddress - the address of the admin to remove.
     */
    removeAdmin(adminAddress: string): Promise<TransactionResult>;
    /**
     * Get all the admins and session keys active on the smart wallet.
     */
    getAllActiveSigners(): Promise<SignerWithPermissions[]>;
    /**
     * Get the underlying account contract of the smart wallet.
     * @returns the account contract of the smart wallet.
     */
    getAccountContract(): Promise<SmartContract>;
    /**
     * Get the underlying account factory contract of the smart wallet.
     * @returns the account factory contract.
     */
    getFactoryContract(): Promise<SmartContract>;
    autoConnect(params: ConnectParams<SmartWalletConnectionArgs>): Promise<string>;
}
//# sourceMappingURL=smart-wallet.d.ts.map