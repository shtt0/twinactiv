'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var defineProperty = require('../../../../dist/defineProperty-6ca2d9a5.cjs.prod.js');
var evm_wallets_base_dist_thirdwebDevWalletsEvmWalletsBase = require('../../../../dist/base-2b21de8d.cjs.prod.js');
var evm_wallets_abstract_dist_thirdwebDevWalletsEvmWalletsAbstract = require('../../abstract/dist/thirdweb-dev-wallets-evm-wallets-abstract.cjs.prod.js');
var walletIds = require('../../../../dist/walletIds-e7ad7ae9.cjs.prod.js');
var chains = require('@thirdweb-dev/chains');
var ethers = require('ethers');
var sdk = require('@thirdweb-dev/sdk');
require('../../../../dist/classPrivateMethodGet-cf746c9e.cjs.prod.js');
require('../../../../dist/classPrivateFieldSet-4a4973f9.cjs.prod.js');
require('eventemitter3');

const sdkCache = new Map();
function getSDK(chain) {
  const cached = sdkCache.get(chain);
  if (cached) {
    return cached;
  }
  const sdk$1 = new sdk.ThirdwebSDK(chain);
  sdkCache.set(chain, sdk$1);
  return sdk$1;
}

/**
 * Get all the signers added to the given smart wallet (excluding owner)
 * @param chain - The chain to use
 * @param factoryAddress - The factory address
 * @param smartWalletAddress - The smart wallet address
 * @returns The list of signers
 */
async function getAllSigners(chain, factoryAddress, smartWalletAddress) {
  const readOnlySDK = getSDK(chain);
  const factoryContract = await readOnlySDK.getContract(factoryAddress);
  const signers = await factoryContract.call("getSignersOfAccount", [smartWalletAddress]);
  return signers;
}

/**
 * Get all the smart wallets associated with a personal wallet address
 * @param chain - The chain to use
 * @param factoryAddress - The factory address
 * @param personalWalletAddress - The personal wallet address
 * @returns The list of smart wallets
 */
async function getAllSmartWallets(chain, factoryAddress, personalWalletAddress) {
  const readOnlySDK = getSDK(chain);
  const factoryContract = await readOnlySDK.getContract(factoryAddress);
  const ownedAccount = await getSmartWalletAddress(chain, factoryAddress, personalWalletAddress);
  const accessibleAccounts = await factoryContract.call("getAccountsOfSigner", [personalWalletAddress]);
  return {
    owned: ownedAccount,
    hasSignerRole: accessibleAccounts
  };
}

/**
 * Check if a smart wallet is deployed for a given personal wallet address
 * @param chain - The chain to use
 * @param factoryAddress - The factory address
 * @param personalWalletAddress - The personal wallet address
 * @returns True if the smart wallet is deployed
 */
async function isSmartWalletDeployed(chain, factoryAddress, personalWalletAddress) {
  let data = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "0x";
  const readOnlySDK = getSDK(chain);
  const factoryContract = await readOnlySDK.getContract(factoryAddress);
  const accountAddress = await factoryContract.call("getAddress", [personalWalletAddress, data]);
  const isDeployed = await sdk.isContractDeployed(accountAddress, readOnlySDK.getProvider());
  return isDeployed;
}

/**
 * Get the associated smart wallet address for a given personal wallet address
 * @param chain - The chain to use
 * @param factoryAddress - The factory address
 * @param personalWalletAddress - The personal wallet address
 * @returns The smart wallet address
 */
async function getSmartWalletAddress(chain, factoryAddress, personalWalletAddress) {
  let data = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "0x";
  const readOnlySDK = getSDK(chain);
  const factoryContract = await readOnlySDK.getContract(factoryAddress);
  const accountAddress = await factoryContract.call("getAddress", [personalWalletAddress, data]);
  return accountAddress;
}

class SmartWallet extends evm_wallets_base_dist_thirdwebDevWalletsEvmWalletsBase.AbstractClientWallet {
  get walletName() {
    return "Smart Wallet";
  }
  constructor(options) {
    if (options.clientId && typeof options.chain === "object") {
      try {
        options.chain = {
          ...options.chain,
          rpc: chains.getValidChainRPCs(options.chain, options.clientId)
        };
      } catch {}
    }
    super(SmartWallet.id, {
      ...options
    });
  }
  async getConnector() {
    if (!this.connector) {
      const {
        SmartWalletConnector
      } = await Promise.resolve().then(function () { return require('../../../connectors/smart-wallet/dist/thirdweb-dev-wallets-evm-connectors-smart-wallet.cjs.prod.js'); });
      this.connector = new SmartWalletConnector(this.options);
    }
    return this.connector;
  }
  getPersonalWallet() {
    return this.connector?.personalWallet;
  }

  /**
   * @returns the signature of the message
   */
  async signMessage(message) {
    // Deploy smart wallet if needed
    const connector = await this.getConnector();
    await connector.deployIfNeeded();
    const erc4337Signer = await this.getSigner();
    const chainId = await erc4337Signer.getChainId();
    const address = await connector.getAddress();

    /**
     * We first try to sign the EIP-712 typed data i.e. the message mixed with the smart wallet's domain separator.
     * If this fails, we fallback to the legacy signing method.
     */
    try {
      const result = await sdk.signTypedDataInternal(erc4337Signer, {
        name: "Account",
        version: "1",
        chainId,
        verifyingContract: address
      }, {
        AccountMessage: [{
          name: "message",
          type: "bytes"
        }]
      }, {
        message: ethers.utils.defaultAbiCoder.encode(["bytes32"], [ethers.utils.hashMessage(message)])
      });
      const isValid = await evm_wallets_abstract_dist_thirdwebDevWalletsEvmWalletsAbstract.checkContractWalletSignature(message, result.signature, address, chainId);
      if (!isValid) {
        throw new Error("Invalid signature");
      }
      return result.signature;
    } catch {
      return await this.signMessageLegacy(erc4337Signer, message);
    }
  }

  /**
   * @returns the signature of the message (for legacy EIP-1271 signature verification)
   */
  async signMessageLegacy(signer, message) {
    return await signer.signMessage(message);
  }

  /**
   * Check whether the connected signer can execute a given transaction using the smart wallet.
   * @param transaction - the transaction to execute using the smart wallet.
   * @returns whether the connected signer can execute the transaction using the smart wallet.
   */
  async hasPermissionToExecute(transaction) {
    const connector = await this.getConnector();
    return connector.hasPermissionToExecute(transaction);
  }

  /**
   * Send a single transaction without waiting for confirmations
   * @param transaction - the transaction to send
   * @returns the transaction result
   */
  async send(transaction) {
    const connector = await this.getConnector();
    return connector.send(transaction);
  }

  /**
   * Execute a single transaction and wait for confirmations
   * @param transaction - the transaction to execute
   * @returns the transaction receipt
   */
  async execute(transaction) {
    const connector = await this.getConnector();
    return connector.execute(transaction);
  }

  /**
   * Send a multiple transaction in a batch without waiting for confirmations
   * @param transactions - the transactions to send
   * @returns the transaction result
   */
  async sendBatch(transactions) {
    const connector = await this.getConnector();
    return connector.sendBatch(transactions);
  }

  /**
   * Execute multiple transactions in a single batch and wait for confirmations
   * @param transactions - the transactions to execute
   * @returns the transaction receipt
   */
  async executeBatch(transactions) {
    const connector = await this.getConnector();
    return connector.executeBatch(transactions);
  }

  /**
   * Send a single raw transaction without waiting for confirmations
   * @param transaction - the transaction to send
   * @returns the transaction result
   */
  async sendRaw(transaction) {
    const connector = await this.getConnector();
    return connector.sendRaw(transaction);
  }

  /**
   * Execute a single raw transaction and wait for confirmations
   * @param transaction - the transaction to execute
   * @returns the transaction receipt
   */
  async executeRaw(transaction) {
    const connector = await this.getConnector();
    return connector.executeRaw(transaction);
  }

  /**
   * Estimate the gas cost of a single transaction
   * @param transaction - the transaction to estimate
   * @returns
   */
  async estimate(transaction) {
    const connector = await this.getConnector();
    return connector.estimate(transaction);
  }

  /**
   * Estimate the gas cost of a batch of transactions
   * @param transactions - the transactions to estimate
   * @returns
   */
  async estimateBatch(transactions) {
    const connector = await this.getConnector();
    return connector.estimateBatch(transactions);
  }

  /**
   * Estimate the gas cost of a single raw transaction
   * @param transactions - the transactions to estimate
   * @returns
   */
  async estimateRaw(transactions) {
    const connector = await this.getConnector();
    return connector.estimateRaw(transactions);
  }

  /**
   * Estimate the gas cost of a batch of raw transactions
   * @param transactions - the transactions to estimate
   * @returns
   */
  async estimateBatchRaw(transactions) {
    const connector = await this.getConnector();
    return connector.estimateBatchRaw(transactions);
  }

  /**
   * Send multiple raw transaction in a batch without waiting for confirmations
   * @param transactions - the transactions to send
   * @returns the transaction result
   */
  async sendBatchRaw(transactions) {
    const connector = await this.getConnector();
    return connector.sendBatchRaw(transactions);
  }

  /**
   * Execute multiple raw transactions in a single batch and wait for confirmations
   * @param transactions - the transactions to execute
   * @returns the transaction receipt
   */
  async executeBatchRaw(transactions) {
    const connector = await this.getConnector();
    return connector.executeBatchRaw(transactions);
  }

  /**
   * Manually deploy the smart wallet contract. If already deployed this will throw an error.
   * Note that this is not necessary as the smart wallet will be deployed automatically on the first transaction the user makes.
   * @returns the transaction receipt
   */
  async deploy() {
    const connector = await this.getConnector();
    return connector.deploy();
  }

  /**
   * Manually deploy the smart wallet contract. If already deployed this will do nothing.
   * Note that this is not necessary as the smart wallet will be deployed automatically on the first transaction the user makes.
   * @returns the transaction receipt
   */
  async deployIfNeeded() {
    const connector = await this.getConnector();
    return connector.deployIfNeeded();
  }

  /**
   * Check if the smart wallet contract is deployed
   * @returns true if the smart wallet contract is deployed
   */
  async isDeployed() {
    const connector = await this.getConnector();
    return connector.isDeployed();
  }

  /**
   * Create and add a session key to the smart wallet.
   * @param keyAddress - the address of the session key to add.
   * @param permissions - the permissions to grant to the session key.
   */
  async createSessionKey(keyAddress, permissions) {
    const connector = await this.getConnector();
    return connector.grantPermissions(keyAddress, permissions);
  }

  /**
   * Remove a session key from the smart wallet.
   * @param keyAddress - the address of the session key to remove.
   */
  async revokeSessionKey(keyAddress) {
    const connector = await this.getConnector();
    return connector.revokePermissions(keyAddress);
  }

  /**
   * Add another admin to the smart wallet.
   * @param adminAddress - the address of the admin to add.
   */
  async addAdmin(adminAddress) {
    const connector = await this.getConnector();
    return connector.addAdmin(adminAddress);
  }

  /**
   * Remove an admin from the smart wallet.
   * @param adminAddress - the address of the admin to remove.
   */
  async removeAdmin(adminAddress) {
    const connector = await this.getConnector();
    return connector.removeAdmin(adminAddress);
  }

  /**
   * Get all the admins and session keys active on the smart wallet.
   */
  async getAllActiveSigners() {
    const connector = await this.getConnector();
    return connector.getAllActiveSigners();
  }

  /**
   * Get the underlying account contract of the smart wallet.
   * @returns the account contract of the smart wallet.
   */
  async getAccountContract() {
    const connector = await this.getConnector();
    return connector.getAccountContract();
  }

  /**
   * Get the underlying account factory contract of the smart wallet.
   * @returns the account factory contract.
   */
  async getFactoryContract() {
    const connector = await this.getConnector();
    return connector.getFactoryContract();
  }
  autoConnect(params) {
    return this.connect(params);
  }
}
defineProperty._defineProperty(SmartWallet, "meta", {
  name: "Smart Wallet",
  iconURL: "ipfs://QmeAJVqn17aDNQhjEU3kcWVZCFBrfta8LzaDGkS8Egdiyk/smart-wallet.svg"
});
defineProperty._defineProperty(SmartWallet, "id", walletIds.walletIds.smartWallet);

exports.SmartWallet = SmartWallet;
exports.getAllSigners = getAllSigners;
exports.getAllSmartWallets = getAllSmartWallets;
exports.getSmartWalletAddress = getSmartWalletAddress;
exports.isSmartWalletDeployed = isSmartWalletDeployed;
